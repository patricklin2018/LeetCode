# 264. 丑数 II

## 问题

编写一个程序，找出第 `n` 个丑数。

丑数就是只包含质因数 `2, 3, 5` 的**正整数**。

**示例:**

```
输入: n = 10
输出: 12
解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
```

**说明:**  

1. `1` 是丑数。
2. `n` **不超过**1690。

## 思路

我们知道，丑数含有因子 2，3，5，也就是说丑数能够被 2，3，5 整除，相应的，丑数也可以表示为 `丑数 = 2 * a + 3 * b + 5 * c`。

如果采用暴力枚举，尝试所有 a、b、c 不仅难以保证从小到大的顺序性，而且效率极地。

这时候需要运用到两条看似废话的特性：

> 对于任何丑数 p ： (1) 2 * p、3 * p、5 * p 也皆为丑数。 (2) 对于丑数 p、q，若 p > q，那么 2 * p > 2 * q，3 * p > 3 * q，5 * p > 5 * q。

对于特性 (1)，我们可以用来枚举丑数，比如，第一个丑数为 1，那么相应就生成了三个丑数 2，3，5。 为了保持顺序性，因此，选取最小者，即 2 作为第二个丑数。

若仅采用特性 (1)，那么，每次得到一个丑数，生成三个丑数加入到丑数池，然后从丑数池中选取最小值，再生成另外三个丑数， 如此循环往复。但是计算效率并不高，维护丑数池，综合来看时间复杂度为 O(n^2)。

因此，我们可以利用特性 (2)，看似废话，其实很好用。比如说，第一个丑数 1，生成了三个丑数 2，3，5。 为了保持顺序性，选取了最小的 2，那么又生成了新一轮的丑数，并且 `2 * 2 < 3 * 2 < 5 * 2`，`2 * 3 < 3 * 3 < 5 * 3`, `2 * 5 < 3 * 5 < 5 * 5`。也就是说，当前轮最小丑数 2，那么下一轮最小丑数也不可能是 `3 * 2, 5 * 2, 3 * 3, 3 * 5, 5 * 2, 5 * 3, 5* 5`。 因此，下一轮也不比将这些加入最小的考虑，那么，丑数池，只要维护 3 个数，而不是每次生成的丑数都加入丑数池。

下面通过举例说明以上思路：

```
ugly[0] = 1 第一个丑数为 1，那么丑数池初始化为(2, 3, 5)
ugly[1] = min(2, 3, 5) = 2，这时丑数池三个数更新为(4, 3, 5)，对应为 (ugly[1] * 2，ugly[0] * 3, ugly[0] * 5)
ugly[2] = min(4, 3, 5) = 3, 这时丑数池三个数更新为(4, 6, 5)，对应为 (ugly[1] * 2，ugly[1] * 3, ugly[0] * 5)
ugly[3] = min(4, 6, 5) = 4, 这时丑数池三个数更新为(6, 6, 5)，对应为 (ugly[2] * 2，ugly[1] * 3, ugly[0] * 5)
ugly[4] = min(6, 6, 5) = 5, 这时丑数池三个数更新为(6, 6, 10)，对应为 (ugly[2] * 2，ugly[1] * 3, ugly[1] * 5)
ugly[5] = min(6, 6, 5) = 6, 这时丑数池三个数更新为(8, 9, 10)，对应为 (ugly[3] * 2，ugly[2] * 3, ugly[1] * 5)
...
```

## 实现

[代码 - Java](Solution.java)

### 1. Java

```java
public class Solution {
    public int nthUglyNumber(int n) {
        if (n < 7) {
            return n;
        }

        int[] ugly = new int[n];
        ugly[0] = 1;
        int t2 = 0, t3 = 0, t5 = 0;
        for (int i = 1; i < n; ++i) {
            ugly[i] = Math.min(ugly[t2] * 2, Math.min(ugly[t3] * 3, ugly[t5] * 5));
            if (ugly[i] == ugly[t2] * 2) {
                t2++;
            }
            if (ugly[i] == ugly[t3] * 3) {
                t3++;
            }
            if (ugly[i] == ugly[t5] * 5) {
                t5++;
            }
        }

        return ugly[n - 1];
    }
}
```

